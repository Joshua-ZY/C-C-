#include <iostream>
#include <algorithm>
using namespace std;

/*描述:某校大门外长度为l的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的
一端在数轴0的位置，另一端在l的位置；数轴上的每个整数点，即0，1，2，……，l，都种有一棵树。马路上有一些区域要
用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间
可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路
上还有多少棵树。
输入:输入的第一行有两个整数l（1 <= l <= 10000）和 M（1 <= M <= 100），l代表马路的长度，M代表区域的数目，l和M
之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。
输出:输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。
由于数据范围不大（l<=10000），我们可以使用一个10001长度的数组来记录每一个坐标上有没有树。但想象一下如果数据范围
很大,你怎么办呢？*/

int main() {
	int l, M;
	cin >> l >> M;
	int starts[100], ends[100];
	for (int i = 0; i < M; i++)
		cin >> starts[i] >> ends[i];
	
	for (int i = 0; i < M; i++) {
		for (int j = i + 1; j < M; j++) {
			if (starts[i] >= ends[j] || starts[j] >= ends[i]) //说明二者无交集
				continue;
			else {
				//如果有交集，那么j取并集，i变为空集，这是因为j后面还会比较，i就不会了，例如有
				//三个集合123，12无交集，13和23有交集，那么如果将并集赋给前一个，会有问题：因
				//为12先比较，无交集，都不变；13比较，有交集，因此1变为13交集，3变为空集；然后
				//23比较，因为2是空集，所以23无交集，都不变，这样最终1和3会有重复；但是如果13比
				//较，3变为交集，1变为空集，则不会有这个问题。
				if (starts[i] < starts[j])
					starts[j] = starts[i];
				if (ends[i] > ends[j])
					ends[j] = ends[i];
				starts[i] = ends[i]; //i变为空集
			}
		}
	}
	l = l + 1;
	for (int i = 0; i < M; i++)
		if (starts[i] != ends[i]) //注意端点两端都有树，但空集的树为0而不是1
			l -= (ends[i] - starts[i] + 1);
	cout << l << endl;
	return 0;
}