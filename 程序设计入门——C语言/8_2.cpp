#include <stdio.h>
#include <string.h>
#define N 200

/*GPS数据处理
NMEA-0183协议是为了在不同的GPS（全球定位系统）导航设备中建立统一的BTCM（海事无线电技术委员会）标准，
由美国国家海洋电子协会（NMEA-The National Marine Electronics Associa-tion）制定的一套通讯协议。GPS
接收机根据NMEA-0183协议的标准规范，将位置、速度等信息通过串口传送到PC机、PDA等设备。
NMEA-0183协议是GPS接收机应当遵守的标准协议，也是目前GPS接收机上使用最广泛的协议，大多数常见的GPS接
收机、GPS数据处理软件、导航软件都遵守或者至少兼容这个协议。
NMEA-0183协议定义的语句非常多，但是常用的或者说兼容性最广的语句只有$GPGGA、$GPGSA、$GPGSV、$GPRMC、
$GPVTG、$GPGLL等。
其中$GPRMC语句的格式如下：$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50
这里整条语句是一个文本行，行中以逗号“,”隔开各个字段，每个字段的大小（长度）不一，这里的示例只是一种
可能，并不能认为字段的大小就如上述例句一样。
字段0：$GPRMC，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息
字段1：UTC时间，hhmmss.sss格式
字段2：状态，A=定位，V=未定位
字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0）
字段4：纬度N（北纬）或S（南纬）
字段5：经度dddmm.mmmm，度分格式（前导位数不足则补0）
字段6：经度E（东经）或W（西经）
字段7：速度，节，Knots
字段8：方位角，度
字段9：UTC日期，DDMMYY格式
字段10：磁偏角，（000 - 180）度（前导位数不足则补0）
字段11：磁偏角方向，E=东W=西
字段16：校验值
这里，“*”为校验和识别符，其后面的两位数为校验和，代表了“$”和“*”之间所有字符（不包括这两个字符）的异或值的十六进制值。
上面这条例句的校验和是十六进制的50，也就是十进制的80。
提示：^运算符的作用是异或。将$和*之间所有的字符做^运算(第一个字符和第二个字符异或，结果再和第三个字符异或，依此类推)
之后的值对65536取余后的结果，应该和*后面的两个十六进制数字的值相等，否则的话说明这条语句在传输中发生了错误。注意这个
十六进制值中是会出现A-F的大写字母的。
现在，你的程序要读入一系列GPS输出，其中包含$GPRMC，也包含其他语句。在数据的最后，有一行单独的END表示数据的结束。

你的程序要从中找出$GPRMC语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。
一次数据中会包含多条$GPRMC语句，以最后一条语句得到的北京时间作为结果输出。
你的程序一定会读到一条有效的$GPRMC语句。
输入格式:多条GPS语句，每条均以回车换行结束。最后一行是END三个大写字母。
输出格式：6位数时间，表达为：hh:mm:ss其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；
ss是两位数的秒，不足两位时前面补0。*/

int findCommaPos(char arr[], int no){ //找到arr中第no个逗号
    int times = 0;
    for(int i = 0; i < N; i++){
        if (arr[i] == ','){
            times++;
            if (times == no)
                return i;
        }
    }
}

int findStarPos(char arr[]){ //找到arr中的星号位置
    for(int i = 0; i < N; i++){
        if (arr[i] == '*'){
            return i;
        }
    }
}

int charto16(char c){ //将16进制的字符串转成16进制数
    if (c >= '0' && c <= '9')
        return c - '0';
    else switch(c){
        case('A'): return 10;
        case('B'): return 11;
        case('C'): return 12;
        case('D'): return 13;
        case('E'): return 14;
        case('F'): return 15;
    }
}

void UTCtoBJ_store(char arr[], int ans[]){
    int hour = (arr[0] - '0') * 10 + (arr[1] - '0');
    int minute = (arr[2] - '0') * 10 + (arr[3] - '0');
    int second = (arr[4] - '0') * 10 + (arr[5] - '0');
    hour += 8;
    if (hour > 24)
        hour -= 24;
    ans[0] = hour;
    ans[1] = minute;
    ans[2] = second;
    return;
}

int main(){
    char info[N]; int time_ans[3] = {-1};
    while(1){
        gets(info);
        if(strcmp(info, "END") == 0){ //strcmp函数返回值：若参数s1 和s2 字符串相同则返回0。s1 若大于s2 则返回大于0 的值。s1 若小于s2 则返回小于0 的值。
            if (time_ans[0] != -1)
                printf("%02d:%02d:%02d", time_ans[0], time_ans[1], time_ans[2]);
            return 0;
        }
        else{
            int comma1 = findCommaPos(info, 1); //找到第一个都好的位置，用来确定字段0
            char sec0[10] = {'\0'};
            for(int i = 0; i < comma1; i++)
                sec0[i] =  info[i];
            if(strcmp(sec0,"$GPRMC") != 0)//判断字段0是否等于"$GPRMC"
                continue;
            int comma2 = findCommaPos(info, 2);//找到第二个逗号的位置，后面就是字段2定位码
            if(info[comma2 + 1] != 'A')
                continue;
            int star = findStarPos(info); //找到星号的位置
            int xorvalue = info[1]^info[2];//计算$到*之间的xor值
            for(int i = 3; i < star; i++)
                xorvalue ^= info[i];
            xorvalue %= 65536;
            int confirm_code = 0;
            for(int i = star + 1; ; i++){
                if (info[i]){
                    confirm_code = confirm_code * 16 + charto16(info[i]);
                }
                else break;
            }
            if (xorvalue != confirm_code) //判断$到*之间的xor值与校验码值是否相等
                continue;
            char time[6];
            for(int i = 0; i < 6; i++)//只要提取时间的前六位即可
                time[i] = info[comma1 + 1 + i];
            UTCtoBJ_store(time, time_ans); //如果一次输入有多条合法的语句，只输出最后一条，所以每次的结果先存储在time里，等到END之后输出；
        }
    }
}
