#include <iostream>
using namespace std;

/*描述:给定一组整数，要求利用数组把这组数保存起来，再利用实现对数组中的数循环移动。假定共有n个整数，则要使前面
各数顺序向后移m个位置，并使最后m各数变为最前面的m各数。注意，不要用先输出后m个数，再输出前n-m个数的方法实现，也
不要用两个数组的方式实现。要求只用一个数组的方式实现，一定要保证在输出结果时，输出的顺序和数组中数的顺序是一致的。
输入:输入有两行：第一行包含一个正整数n和一个正整数m，第二行包含n个正整数。每两个正整数中间用一个空格分开。
输出:输出有一行：经过循环移动后数组中整数的顺序依次输出，每两个整数之间用空格分隔。*/

/*这是一道经典的算法问题，在企业面试里出现概率很高。除了循环m次每次移动一个数以外（这样需要对数组操作m*n次），
你还能想到更高效的算法吗（只用操作3*n次）？依然要求不使用额外数组，在原数组上移位之后顺序输出。
方法：进行三次逆序变换。比如要将123456abc向后移动3位，首先将后三位和其他部分分别倒过来，因此得到654321和cba，然后将
整体倒过来，即将654321cba倒过来，得到abc123456。其原理是如果想将序列向后移动m位，那么可以将序列分成两部分，后m位和
前n-m位。想要将后m位变到前n-m位的前面，可以直接将整个序列倒置，但是这样的话虽然后m位整体在前n-m位的前面了，但是后m位
的内容和前n-m位的内容也都倒过来了。所以先将后m位和前n-m位的内容内部倒过来，然后再将序列整体倒置即可。将一个序列倒置
需要3n/2次操作，因为一个长度为n的序列要进行2/n次交换，每次交换要将i位的值赋给temp，n-i位的值赋给i，temp的值赋给n-i位。
而将整个序列移动n位需要倒置3次，每次倒置的序列的长度分别为n-m,m,n，因此总共需要倒置n-m+m+n = 2n长度的序列，因此整个
移动需要操作3*n次。*/

int main() {
	int n, m;
	cin >> n >> m;
	int vec[100], temp;
	for (int i = 0; i < n; i++) 
		cin >> vec[i];
	//倒置前n-m位
	for (int r = 0, l = n - m - 1; r < l; r++, l--) {
		temp = vec[r];
		vec[r] = vec[l];
		vec[l] = temp;
	}
	//倒置后m位
	for (int r = n - m, l = n - 1; r < l; r++, l--) {
		temp = vec[r];
		vec[r] = vec[l];
		vec[l] = temp;
	}
	//倒置整个序列
	for (int r = 0, l = n - 1; r < l; r++, l--) {
		temp = vec[r];
		vec[r] = vec[l];
		vec[l] = temp;
	}
	//输出序列
	for (int i = 0; i < n; i++) 
		cout << vec[i] << ' ';
	cout << endl;
	return 0;
}